import os
import shutil
import subprocess
import socket
import time
from typing import Dict, Optional

from cfg.config import SUB_PORT


class SSHTunnelManager:
    """
    Простой и надежный менеджер SSH туннелей
    """
    _instance = None
    _tunnels: Dict[str, subprocess.Popen] = {}
    _local_ports: Dict[str, int] = {}

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            self.initialized = True
            self._start_port = 20000
            self._setup_ssh_keys()

    def _setup_ssh_keys(self):
        """Копирует SSH ключи из смонтированной папки"""
        if not os.path.exists('/host_ssh'):
            print("❌ /host_ssh не найден")
            return False

        os.makedirs('/root/.ssh', exist_ok=True)
        os.chmod('/root/.ssh', 0o700)

        for filename in os.listdir('/host_ssh'):
            source_path = f'/host_ssh/{filename}'
            if os.path.isfile(source_path):
                shutil.copy2(source_path, f'/root/.ssh/{filename}')
                target_path = f'/root/.ssh/{filename}'
                if filename.endswith('.pub'):
                    os.chmod(target_path, 0o644)
                else:
                    os.chmod(target_path, 0o600)

        print("✅ SSH ключи настроены")
        return True

    def get_tunnel_port(self, server_ip: str) -> Optional[int]:
        """Получает порт для туннеля, создает если нужно"""
        # Если туннель уже есть и процесс жив - возвращаем порт
        if server_ip in self._local_ports:
            process = self._tunnels[server_ip]
            if process.poll() is None:  # Процесс жив
                return self._local_ports[server_ip]
            else:
                # Процесс умер - удаляем из кэша
                del self._tunnels[server_ip]
                del self._local_ports[server_ip]

        # Проверяем SSH ключ
        if not os.path.exists('/root/.ssh/id_ed25519'):
            print(f"❌ SSH ключ не найден")
            return None

        # Находим свободный порт (простой способ)
        local_port = self._start_port + len(self._local_ports)

        # Если порт занят - ищем следующий
        while self._is_port_busy(local_port):
            local_port += 1

        return self._create_tunnel(server_ip, local_port)

    def _is_port_busy(self, port: int) -> bool:
        """Простая проверка занятости порта"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.bind(('localhost', port))
                return False  # Порт свободен
        except OSError:
            return True  # Порт занят

    def _create_tunnel(self, server_ip: str, local_port: int) -> Optional[int]:
        """Создает SSH туннель"""
        cmd = [
            'ssh', '-N', '-q',  # -q для тишины
            '-o', 'ServerAliveInterval=60',
            '-o', 'ServerAliveCountMax=3',
            '-o', 'ConnectTimeout=10',
            '-o', 'ExitOnForwardFailure=yes',  # Выходить если туннель не создался
            '-i', '/root/.ssh/id_ed25519',
            '-L', f'{local_port}:localhost:{SUB_PORT}',
            '-p', '10022',
            '-o', 'StrictHostKeyChecking=no',
            '-o', 'UserKnownHostsFile=/dev/null',
            f'root@{server_ip}'
        ]

        try:
            process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

            # Даем время на установку туннеля
            time.sleep(3)

            # Проверяем что процесс еще жив
            if process.poll() is None:
                self._tunnels[server_ip] = process
                self._local_ports[server_ip] = local_port
                print(f"✅ SSH туннель: {server_ip} -> localhost:{local_port}")
                return local_port
            else:
                print(f"❌ SSH туннель не создался для {server_ip}")
                return None

        except Exception as e:
            print(f"❌ Ошибка SSH туннеля для {server_ip}: {e}")
            return None

    def cleanup(self):
        """Закрывает все туннели"""
        for server_ip, process in self._tunnels.items():
            try:
                process.terminate()
                process.wait(timeout=3)
                print(f"✅ Туннель {server_ip} закрыт")
            except:
                process.kill()
                print(f"⚠️ Туннель {server_ip} принудительно закрыт")

        self._tunnels.clear()
        self._local_ports.clear()