import asyncio
import subprocess
import os
import shutil
import threading
from typing import Dict, Optional
from dataclasses import dataclass
from datetime import datetime


@dataclass
class TunnelInfo:
    process: subprocess.Popen
    local_port: int
    created_at: datetime
    health_check_count: int = 0


class SSHTunnelManager:
    """
    Thread-safe –º–µ–Ω–µ–¥–∂–µ—Ä SSH —Ç—É–Ω–Ω–µ–ª–µ–π —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∑–¥–æ—Ä–æ–≤—å—è
    """
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:  # Double-checked locking
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not hasattr(self, 'initialized'):
            with self._lock:
                if not hasattr(self, 'initialized'):
                    self.initialized = True
                    self._tunnels: Dict[str, TunnelInfo] = {}
                    self._start_port = 20000
                    self._port_lock = asyncio.Lock()
                    self._setup_ssh_keys()

    def _setup_ssh_keys(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ SSH –∫–ª—é—á–µ–π —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        if not os.path.exists('/host_ssh'):
            print("‚ùå /host_ssh –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return False

        ssh_dir = '/root/.ssh'
        os.makedirs(ssh_dir, exist_ok=True)
        os.chmod(ssh_dir, 0o700)

        try:
            for filename in os.listdir('/host_ssh'):
                src_path = f'/host_ssh/{filename}'
                if os.path.isfile(src_path):
                    dst_path = f'{ssh_dir}/{filename}'
                    shutil.copy2(src_path, dst_path)

                    # –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
                    if filename.endswith('.pub'):
                        os.chmod(dst_path, 0o644)
                    else:
                        os.chmod(dst_path, 0o600)

            print("‚úÖ SSH –∫–ª—é—á–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã")
            return True
        except Exception as e:
            print(f"‚ùå –û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SSH –∫–ª—é—á–µ–π: {e}")
            return False

    async def _check_tunnel_health(self, server_ip: str, tunnel_info: TunnelInfo) -> bool:
        """
        –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ —Ç—É–Ω–Ω–µ–ª—è —á–µ—Ä–µ–∑ —Ä–µ–∞–ª—å–Ω–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
        """
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø—Ä–æ—Ü–µ—Å—Å –µ—â–µ –∂–∏–≤
            if tunnel_info.process.poll() is not None:
                return False

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ—Ä—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Å–ª—É—à–∞–µ—Ç
            import socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)

            try:
                result = sock.connect_ex(('localhost', tunnel_info.local_port))
                return result == 0
            finally:
                sock.close()

        except Exception:
            return False

    async def get_tunnel_port(self, server_ip: str) -> Optional[int]:
        """Thread-safe –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Ä—Ç–∞ —Ç—É–Ω–Ω–µ–ª—è —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∑–¥–æ—Ä–æ–≤—å—è"""
        from logger.logging_config import logger

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç—É–Ω–Ω–µ–ª—å
        if server_ip in self._tunnels:
            tunnel_info = self._tunnels[server_ip]

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ —Ç—É–Ω–Ω–µ–ª—è
            if await self._check_tunnel_health(server_ip, tunnel_info):
                tunnel_info.health_check_count += 1
                await logger.info(f"‚ôªÔ∏è –ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É–Ω–Ω–µ–ª—å: {server_ip}:{tunnel_info.local_port}")
                return tunnel_info.local_port
            else:
                # –¢—É–Ω–Ω–µ–ª—å –º–µ—Ä—Ç–≤, —É–¥–∞–ª—è–µ–º
                await self._cleanup_tunnel(server_ip)
                await logger.warning(f"üîÑ –¢—É–Ω–Ω–µ–ª—å –º–µ—Ä—Ç–≤, –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º: {server_ip}")

        # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π —Ç—É–Ω–Ω–µ–ª—å (thread-safe)
        async with self._port_lock:
            return await self._create_new_tunnel(server_ip)

    async def _create_new_tunnel(self, server_ip: str) -> Optional[int]:
        """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π SSH —Ç—É–Ω–Ω–µ–ª—å"""
        from logger.logging_config import logger

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º SSH –∫–ª—é—á
        ssh_key_path = '/root/.ssh/id_ed25519'
        if not os.path.exists(ssh_key_path):
            await logger.log_error(f"SSH –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω: {ssh_key_path}", None)
            return None

        # –í—ã–±–∏—Ä–∞–µ–º —Å–≤–æ–±–æ–¥–Ω—ã–π –ø–æ—Ä—Ç
        local_port = await self._get_free_port()
        if not local_port:
            await logger.log_error("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Å–≤–æ–±–æ–¥–Ω—ã–π –ø–æ—Ä—Ç", None)
            return None

        # –ö–æ–º–∞–Ω–¥–∞ SSH —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
        cmd = [
            'ssh', '-N',
            '-o', 'ServerAliveInterval=30',
            '-o', 'ServerAliveCountMax=3',
            '-o', 'ConnectTimeout=10',
            '-o', 'StrictHostKeyChecking=no',
            '-o', 'UserKnownHostsFile=/dev/null',
            '-o', 'LogLevel=ERROR',  # –£–±–∏—Ä–∞–µ–º –ª–∏—à–Ω–∏–µ –ª–æ–≥–∏
            '-i', ssh_key_path,
            '-L', f'{local_port}:localhost:{PORT_X_UI}',
            '-p', '10022',
            f'root@{server_ip}'
        ]

        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                preexec_fn=os.setsid  # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≥—Ä—É–ø–ø—É –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            )

            # –ñ–¥–µ–º —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            for attempt in range(10):  # 5 —Å–µ–∫—É–Ω–¥ –º–∞–∫—Å–∏–º—É–º
                await asyncio.sleep(0.5)

                if process.poll() is not None:
                    # –ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π
                    stderr = process.stderr.read().decode() if process.stderr else ""
                    await logger.log_error(f"SSH –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –¥–ª—è {server_ip}: {stderr}", None)
                    return None

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç—É–Ω–Ω–µ–ª—å —Ä–∞–±–æ—Ç–∞–µ—Ç
                if await self._test_tunnel_connection(local_port):
                    tunnel_info = TunnelInfo(
                        process=process,
                        local_port=local_port,
                        created_at=datetime.now()
                    )
                    self._tunnels[server_ip] = tunnel_info
                    await logger.info(f"‚úÖ SSH —Ç—É–Ω–Ω–µ–ª—å —Å–æ–∑–¥–∞–Ω: {server_ip} -> localhost:{local_port}")
                    return local_port

            # –¢–∞–π–º–∞—É—Ç —Å–æ–∑–¥–∞–Ω–∏—è —Ç—É–Ω–Ω–µ–ª—è
            process.terminate()
            await logger.log_error(f"–¢–∞–π–º–∞—É—Ç —Å–æ–∑–¥–∞–Ω–∏—è —Ç—É–Ω–Ω–µ–ª—è –¥–ª—è {server_ip}", None)
            return None

        except Exception as e:
            await logger.log_error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è SSH —Ç—É–Ω–Ω–µ–ª—è –¥–ª—è {server_ip}", e)
            return None

    async def _get_free_port(self) -> Optional[int]:
        """–ù–∞—Ö–æ–¥–∏—Ç —Å–≤–æ–±–æ–¥–Ω—ã–π –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ—Ä—Ç"""
        import socket

        for port in range(self._start_port, self._start_port + 1000):
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ—Ä—Ç –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞—à–∏–º–∏ —Ç—É–Ω–Ω–µ–ª—è–º–∏
            if port in [info.local_port for info in self._tunnels.values()]:
                continue

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ—Ä—Ç —Å–≤–æ–±–æ–¥–µ–Ω –≤ —Å–∏—Å—Ç–µ–º–µ
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                sock.bind(('localhost', port))
                sock.close()
                return port
            except OSError:
                continue

        return None

    async def _test_tunnel_connection(self, local_port: int) -> bool:
        """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç —á—Ç–æ —Ç—É–Ω–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç"""
        import socket

        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)

        try:
            result = sock.connect_ex(('localhost', local_port))
            return result == 0
        except:
            return False
        finally:
            sock.close()

    async def _cleanup_tunnel(self, server_ip: str):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Ç—É–Ω–Ω–µ–ª—å"""
        if server_ip not in self._tunnels:
            return

        tunnel_info = self._tunnels[server_ip]
        process = tunnel_info.process

        try:
            # –ó–∞–≤–µ—Ä—à–∞–µ–º –≥—Ä—É–ø–ø—É –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ (–≤–∫–ª—é—á–∞—è SSH)
            os.killpg(os.getpgid(process.pid), 15)  # SIGTERM

            # –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ graceful shutdown
            try:
                process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                os.killpg(os.getpgid(process.pid), 9)  # SIGKILL

        except (ProcessLookupError, OSError):
            pass  # –ü—Ä–æ—Ü–µ—Å—Å —É–∂–µ –º–µ—Ä—Ç–≤

        # –£–¥–∞–ª—è–µ–º –∏–∑ –∫—ç—à–∞
        del self._tunnels[server_ip]
        del self._local_ports[server_ip]

    async def cleanup_all(self):
        """–ó–∞–∫—Ä—ã–≤–∞–µ—Ç –≤—Å–µ —Ç—É–Ω–Ω–µ–ª–∏ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏"""
        tasks = []
        for server_ip in list(self._tunnels.keys()):
            tasks.append(self._cleanup_tunnel(server_ip))

        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
            print("üßπ –í—Å–µ SSH —Ç—É–Ω–Ω–µ–ª–∏ –∑–∞–∫—Ä—ã—Ç—ã")

    async def get_tunnel_stats(self) -> Dict[str, dict]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç—É–Ω–Ω–µ–ª–µ–π –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        stats = {}
        for server_ip, tunnel_info in self._tunnels.items():
            is_alive = await self._check_tunnel_health(server_ip, tunnel_info)
            stats[server_ip] = {
                'local_port': tunnel_info.local_port,
                'created_at': tunnel_info.created_at.isoformat(),
                'health_checks': tunnel_info.health_check_count,
                'is_alive': is_alive,
                'pid': tunnel_info.process.pid
            }
        return stats