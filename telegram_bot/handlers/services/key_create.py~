import asyncio
import base64
import json
import os
import random
import string
import uuid

import aiohttp

from config_data.config import MY_SECRET_URL, PORT_X_UI
from handlers.services.get_session_cookies import get_session_cookie

LIMIT = 2


class ServerUnavailableError(Exception):
    """Кастомное исключение для недоступного сервера."""
    pass


class BaseKeyManager:
    def __init__(self, server_ip):
        self.server_ip = server_ip
        self.base_url = f"https://{server_ip}:{PORT_X_UI}/{MY_SECRET_URL}/panel"

    @staticmethod
    def generate_uuid():
        return str(uuid.uuid4())

    @staticmethod
    def generate_port():
        return random.randint(10000, 65535)

    async def get_inbounds(self):
        list_api_url = f"{self.base_url}/inbound/list"
        cookies = await get_session_cookie(self.server_ip)
        async with aiohttp.ClientSession() as session:
            async with session.post(list_api_url, cookies=cookies, ssl=False) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history,
                        status=response.status, message=await response.text()
                    )

    async def get_inbound_by_id(self, inbound_id):
        get_inbound_api_url = f"{self.base_url}/api/inbounds/get/{inbound_id}"
        cookies = await get_session_cookie(self.server_ip)
        async with aiohttp.ClientSession() as session:
            async with session.get(get_inbound_api_url, cookies=cookies, ssl=False) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history,
                        status=response.status, message=await response.text()
                    )

    async def get_traffic_by_id(self, inbound_id):
        get_traffic_api_url = f"{self.base_url}/api/inbounds/getClientTrafficsById/{inbound_id}"
        cookies = await get_session_cookie(self.server_ip)
        async with aiohttp.ClientSession() as session:
            async with session.get(get_traffic_api_url, cookies=cookies, ssl=False) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history,
                        status=response.status, message=await response.text()
                    )

    async def get_online_users(self):
        url = f"{self.base_url}/inbound/onlines"
        cookies = await get_session_cookie(self.server_ip)
        async with aiohttp.ClientSession() as session:
            async with session.post(url, cookies=cookies, ssl=False) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history,
                        status=response.status, message=await response.text()
                    )

    async def delete_key(self, key_id: str):
        """
        Удаляет ключ с указанным key_id.

        Args:
            key_id (str): Идентификатор ключа для удаления.
        """
        delete_api_url = f"{self.base_url}/api/inbounds/del/{key_id}"

        async with aiohttp.ClientSession() as session:
            cookies = await get_session_cookie(self.server_ip)
            async with session.post(delete_api_url, cookies=cookies, ssl=False) as response:
                if response.status == 200:
                    print(f"Key with ID {key_id} successfully deleted.")
                elif response.status == 401:
                    # Получаем новый session_cookie
                    cookies = await get_session_cookie(self.server_ip)
                    async with session.post(delete_api_url, cookies=cookies, ssl=False) as retry_response:
                        if retry_response.status == 200:
                            print(f"Key with ID {key_id} successfully deleted after refreshing session.")
                        else:
                            error_text = await retry_response.text()
                            print(f"Error deleting key after retry: {retry_response.status}, {error_text}")
                            raise aiohttp.ClientResponseError(
                                retry_response.request_info, retry_response.history,
                                status=retry_response.status, message=error_text
                            )
                else:
                    error_text = await response.text()
                    print(f"Error deleting key: {response.status}, {error_text}")
                    raise aiohttp.ClientResponseError(
                        response.request_info, response.history,
                        status=response.status, message=error_text
                    )

    async def update_key_enable(self, key_id: str, enable: bool):
        """
        Обновляет только поле `enable` для ключа с указанным key_id.

        Args:
            key_id (str): Идентификатор ключа для обновления.
            enable (bool): Новый статус для поля `enable`.

        Raises:
            ValueError: Если ключ не удалось получить или обновить.
        """
        # Получаем текущий объект ключа
        get_api_url = f"{self.base_url}/api/inbounds/get/{key_id}"
        update_api_url = f"{self.base_url}/api/inbounds/update/{key_id}"

        async with aiohttp.ClientSession() as session:
            try:
                cookies = await get_session_cookie(self.server_ip)
                async with session.get(get_api_url, cookies=cookies, ssl=False) as response:
                    if response.status != 200:
                        error_text = await response.text()
                        raise ValueError(f"Failed to fetch key with ID {key_id}: {response.status}, {error_text}")

                    data = await response.json()
                    if not data.get("success"):
                        raise ValueError(
                            f"API Error while fetching key with ID {key_id}: {data.get('msg', 'Unknown error')}"
                        )

                    # Получаем объект ключа
                    key_data = data["obj"]

                # Обновляем только поле `enable` в объекте
                key_data["enable"] = enable

                # Если поле `settings` или `streamSettings` — строка, декодируем для обновления
                if isinstance(key_data.get("settings"), str):
                    key_data["settings"] = json.loads(key_data["settings"])
                if isinstance(key_data.get("streamSettings"), str):
                    key_data["streamSettings"] = json.loads(key_data["streamSettings"])
                if isinstance(key_data.get("sniffing"), str):
                    key_data["sniffing"] = json.loads(key_data["sniffing"])

                # Возвращаем преобразованные строки
                key_data["settings"] = json.dumps(key_data["settings"])
                key_data["streamSettings"] = json.dumps(key_data["streamSettings"])
                key_data["sniffing"] = json.dumps(key_data["sniffing"])

                # Отправляем обновленный объект на сервер
                async with session.post(update_api_url, cookies=cookies, json=key_data,
                                        ssl=False) as update_response:
                    if update_response.status == 200:
                        print(f"Key with ID {key_id} successfully updated to {'enabled' if enable else 'disabled'}.")
                    elif update_response.status == 401:
                        cookies = await get_session_cookie(self.server_ip)

                        async with session.post(update_api_url, cookies=cookies, json=key_data,
                                                ssl=False) as retry_response:
                            if retry_response.status == 200:
                                print(f"Key with ID {key_id} successfully updated after refreshing session.")
                            else:
                                error_text = await retry_response.text()
                                raise ValueError(
                                    f"Failed to update key with ID {key_id} after retry: {retry_response.status}, {error_text}")
                    else:
                        error_text = await update_response.text()
                        raise ValueError(
                            f"Failed to update key with ID {key_id}: {update_response.status}, {error_text}")

            except aiohttp.ClientError as e:
                raise ValueError(f"HTTP Client Error while processing key with ID {key_id}: {e}")
            except ValueError as e:
                # Логируем ошибку и возвращаем информативное сообщение
                print(f"Error: {e}")
                raise
            except Exception as e:
                print(f"Unexpected error while updating key with ID {key_id}: {e}")
                raise ValueError(f"Unexpected error while updating key with ID {key_id}: {e}")


class VlessKeyManager(BaseKeyManager):
    def __init__(self, server_ip):
        super().__init__(server_ip)
        self.get_cert_api_url = f"https://{server_ip}:{PORT_X_UI}/{MY_SECRET_URL}/server/getNewX25519Cert"

    async def get_certificate(self, session):
        max_retries = 3
        retries = 0

        while retries < max_retries:
            try:
                cookies = await get_session_cookie(self.server_ip)
                async with session.post(self.get_cert_api_url, cookies=cookies, ssl=False) as response:
                    if response.status == 200:
                        cert_data = await response.json()
                        if cert_data.get("success"):
                            return cert_data["obj"]
                        else:
                            print(f"Certificate generation failed (attempt {retries + 1}/{max_retries})")
                            retries += 1
                            await asyncio.sleep(1)
                    else:
                        print(f"Error getting certificate: {response.status} (attempt {retries + 1}/{max_retries})")
                        retries += 1
                        await asyncio.sleep(1)
            except Exception as e:
                print(f"Exception during certificate request: {e} (attempt {retries + 1}/{max_retries})")
                retries += 1
                await asyncio.sleep(1)

        raise ValueError("Failed to generate certificate after multiple attempts")

    async def create_vless_key(self, session, new_client, private_key, public_key):
        create_api_url = f"{self.base_url}/inbound/add"
        max_retries = 5
        retries = 0

        while True:
            # Получаем (или обновляем) куки
            cookies = await get_session_cookie(self.server_ip)

            port = self.generate_port()
            short_id = uuid.uuid4().hex[:8]
            sub_id = str(uuid.uuid4())

            new_vless_key_data = {
                "up": 0,
                "down": 0,
                "total": 0,
                "remark": new_client["remark"],
                "enable": True,
                "expiryTime": 0,
                "listen": "",
                "port": port,
                "protocol": "vless",
                "settings": json.dumps({
                    "clients": [
                        {
                            "id": new_client["id"],
                            "flow": "xtls-rprx-vision-udp443",
                            "email": new_client.get("email", ""),
                            "limitIp": LIMIT,
                            "totalGB": 0,
                            "expiryTime": 0,
                            "enable": True,
                            "tgId": new_client.get("tgId", ""),
                            "subId": sub_id,
                            "reset": 0
                        }
                    ],
                    "decryption": "none",
                    "fallbacks": []
                }),
                "streamSettings": json.dumps({
                    "network": "tcp",
                    "security": "reality",
                    "externalProxy": [],
                    "realitySettings": {
                        "show": False,
                        "xver": 0,
                        "dest": "google.com:443",
                        "serverNames": ["google.com", "www.google.com"],
                        "privateKey": private_key,
                        "minClient": "",
                        "maxClient": "",
                        "maxTimediff": 0,
                        "shortIds": [
                            "99", "b5056a7fd4c966", "7a331546705f21a6", "0f6e",
                            "2f08168c", "c68d0a1befc3", "53b0e4", "e3b7a4adcc"
                        ],
                        "settings": {
                            "publicKey": public_key,
                            "fingerprint": "chrome",
                            "serverName": "",
                            "spiderX": "/"
                        }
                    },
                    "tcpSettings": {
                        "acceptProxyProtocol": False,
                        "header": {"type": "none"}
                    }
                }),
                "sniffing": json.dumps({
                    "enabled": True,
                    "destOverride": ["http", "tls", "quic", "fakedns"],
                    "metadataOnly": False,
                    "routeOnly": False
                }),
                "allocate": json.dumps({
                    "strategy": "always",
                    "refresh": 5,
                    "concurrency": 3
                })
            }

            try:
                # Попытка отправить запрос с текущими данными
                async with session.post(
                        create_api_url,
                        cookies=cookies,
                        json=new_vless_key_data,
                        ssl=False
                ) as response:
                    if response.status == 200:
                        # Если запрос успешен, возвращаем результат
                        return await response.json(), port, short_id
                    elif response.status == 400 and "port already in use" in (await response.text()).lower():
                        print(f"Port {port} is already in use, trying a new port...")
                        continue
                    else:
                        retries += 1
                        if retries >= max_retries:
                            raise aiohttp.ClientResponseError(
                                response.request_info, response.history,
                                status=response.status, message=await response.text()
                            )
                        print(f"Error creating VLESS key: {response.status} (attempt {retries}/{max_retries})")
                        await asyncio.sleep(1)
            except aiohttp.ClientError as e:
                retries += 1
                if retries >= max_retries:
                    print(f"An error occurred during the request: {e}")
                    raise
                print(f"Client error: {e} (attempt {retries}/{max_retries})")
                await asyncio.sleep(1)

    async def manage_vless_key(self, tg_id, username, server_name):
        max_retries = 3
        retries = 0

        while retries < max_retries:
            try:
                async with aiohttp.ClientSession() as session:
                    new_client = {
                        "id": self.generate_uuid(),
                        "flow": "xtls-rprx-vision",
                        "email": self.generate_uuid(),
                        "limitIp": LIMIT,
                        "totalGB": 0,
                        "expiryTime": 0,
                        "enable": True,
                        "tgId": tg_id,
                        "remark": f"Пользователь: {username}, TgId: {tg_id}"
                    }

                    cert_data = await self.get_certificate(session)
                    response, port, short_id = await self.create_vless_key(
                        session,
                        new_client,
                        cert_data["privateKey"],
                        cert_data["publicKey"],
                    )

                    if not response or 'obj' not in response or 'id' not in response['obj']:
                        print(f"Invalid response format: {response}")
                        retries += 1
                        await asyncio.sleep(1)
                        continue

                    key_id = response['obj']['id']
                    vless_link = self.generate_vless_link(
                        client_id=new_client["id"],
                        port=port,
                        short_id=short_id,
                        public_key=cert_data["publicKey"],
                        server_name=server_name
                    )
                    return vless_link, key_id, email

            except Exception as e:
                print(f"Error creating VLESS key (attempt {retries + 1}/{max_retries}): {e}")
                retries += 1
                await asyncio.sleep(2)

        # Если после всех попыток ключ не создан
        raise Exception(f"Failed to create VLESS key after {max_retries} attempts")

    def generate_vless_link(self, client_id, port, short_id, public_key, server_name):
        return (f"vless://{client_id}@{self.server_ip}:{port}"
                f"?type=tcp&security=reality&pbk={public_key}"
                f"&fp=chrome&sni=google.com&sid={short_id}&spx=%2F&flow=xtls-rprx-vision"
                f"#{server_name} - VLESS")


class ShadowsocksKeyManager(BaseKeyManager):
    async def create_shadowsocks_key(self, session, new_client, new_password, new_port, tg_id, username):
        create_api_url = f"{self.base_url}/inbound/add"
        max_retries = 5
        retries = 0

        while True:
            cookies = await get_session_cookie(self.server_ip)

            new_ss_key_data = {
                "up": 0,
                "down": 0,
                "total": 0,
                "remark": f"Пользователь: {username}, TgId: {tg_id}",
                "enable": True,
                "expiryTime": 0,
                "listen": "",
                "port": new_port,
                "protocol": "shadowsocks",
                "settings": json.dumps({
                    "method": "chacha20-ietf-poly1305",
                    "password": new_password,
                    "network": "tcp,udp",
                    "clients": [new_client],
                    "ivCheck": False
                }),
                "streamSettings": json.dumps({
                    "network": "tcp",
                    "security": "none",
                    "tcpSettings": {
                        "acceptProxyProtocol": False,
                        "header": {"type": "none"}
                    },
                    "externalProxy": []
                }),
                "sniffing": json.dumps({
                    "enabled": True,
                    "destOverride": ["http", "tls", "quic", "fakedns"],
                    "metadataOnly": False,
                    "routeOnly": False
                }),
                "allocate": json.dumps({
                    "strategy": "always",
                    "refresh": 5,
                    "concurrency": 3
                })
            }

            try:
                async with session.post(
                        create_api_url,
                        cookies=cookies,
                        json=new_ss_key_data,
                        ssl=False
                ) as response:
                    if response.status == 200:
                        response_data = await response.json()
                        response_data['password'] = new_password
                        return response_data
                    elif response.status == 401:
                        # Если ошибка авторизации, перезапрашиваем куки
                        print("Cookies expired, re-authenticating...")
                        cookies = await get_session_cookie(self.server_ip)
                        if not cookies:
                            raise Exception("Re-authentication failed.")
                    elif response.status == 400 and "port already in use" in (await response.text()).lower():
                        print(f"Port {new_port} is already in use, trying a new port...")
                        new_port = self.generate_port()
                        continue
                    else:
                        retries += 1
                        if retries >= max_retries:
                            raise aiohttp.ClientResponseError(
                                response.request_info, response.history,
                                status=response.status, message=await response.text()
                            )
                        print(f"Error creating Shadowsocks key: {response.status} (attempt {retries}/{max_retries})")
                        await asyncio.sleep(1)
            except aiohttp.ClientError as e:
                retries += 1
                if retries >= max_retries:
                    print(f"An error occurred during the request: {e}")
                    raise
                print(f"Client error: {e} (attempt {retries}/{max_retries})")
                await asyncio.sleep(1)

    async def manage_shadowsocks_key(self, tg_id, username, server_name):
        max_retries = 3
        retries = 0

        while retries < max_retries:
            try:
                async with aiohttp.ClientSession() as session:
                    new_port = self.generate_port()
                    new_password = base64.b64encode(os.urandom(32)).decode('utf-8')
                    email = self.generate_short_id()
                    method = "chacha20-ietf-poly1305"

                    new_client = {
                        "method": method,
                        "password": new_password,
                        "email": email,
                        "limitIp": LIMIT,
                        "totalGB": 0,
                        "expiryTime": 0,
                        "enable": True,
                        "tgId": tg_id,
                        "subId": self.generate_subid(),
                        "comment": "",
                        "reset": 0
                    }

                    response = await self.create_shadowsocks_key(session, new_client, new_password, new_port, tg_id,
                                                                 username)

                    if not response or 'obj' not in response or 'id' not in response['obj']:
                        print(f"Invalid response format: {response}")
                        retries += 1
                        await asyncio.sleep(1)
                        continue

                    key_id = response['obj']['id']
                    ss_link = self.generate_ss_link(new_port, new_password, method, key_id, server_name)
                    return ss_link, key_id, email

            except Exception as e:
                print(f"Error creating Shadowsocks key (attempt {retries + 1}/{max_retries}): {e}")
                retries += 1
                await asyncio.sleep(2)

        # Если после всех попыток ключ не создан
        raise Exception(f"Failed to create Shadowsocks key after {max_retries} attempts")

    def generate_ss_link(self, port, password, method, key_id, server_name):
        user_info = f"{method}:{password}".encode()
        user_info_base64 = base64.b64encode(user_info).decode()
        return f"ss://{user_info_base64}@{self.server_ip}:{port}?prefix=POST%20&type=tcp#{server_name} - Shadowsocks"

    def generate_short_id(self, length=8):
        """Генерирует короткий идентификатор из букв и цифр."""
        characters = string.ascii_lowercase + string.digits
        return ''.join(random.choice(characters) for _ in range(length))

    def generate_subid(self, length=16):
        """Генерирует ID подписки из букв и цифр."""
        characters = string.ascii_lowercase + string.digits
        return ''.join(random.choice(characters) for _ in range(length))
