from datetime import datetime, timedelta

from aiogram.fsm.context import FSMContext
from aiogram.types import Message, InlineKeyboardMarkup, InlineKeyboardButton

from database.context_manager import DatabaseContextManager
from handlers.services.active_servers import get_active_server_and_key
from handlers.services.create_subscription_service import SubscriptionService
from handlers.services.create_transaction_service import TransactionService
from handlers.services.extend_latest_subscription import NoAvailableServersError, extend_user_subscription
from handlers.services.key_create import BaseKeyManager
from keyboards.kb_inline import InlineKeyboards
from lexicon.lexicon_ru import LEXICON_RU
from logger.logging_config import logger
from models.models import StatusSubscriptionHistory, SubscriptionStatusEnum, Subscriptions, NameApp


class NoActiveSubscriptionsError(Exception):
    pass


class SubscriptionsService:
    """
    –°–µ—Ä–≤–∏—Å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫ –≤ —Å–∏—Å—Ç–µ–º–µ.

    –≠—Ç–æ—Ç –∫–ª–∞—Å—Å —É–ø—Ä–∞–≤–ª—è–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ–º —Å–æ–∑–¥–∞–Ω–∏—è –∏ –ø—Ä–æ–¥–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–æ–∫, –∞ —Ç–∞–∫–∂–µ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π.
    """

    @staticmethod
    async def process_new_subscription(message: Message):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –ø–ª–∞—Ç–µ–∂–µ.

        –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ –ø–ª–∞—Ç–µ–∂–µ, —Å–æ–∑–¥–∞–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∏ –ø–æ–¥–ø–∏—Å–∫—É,
        –∞ –∑–∞—Ç–µ–º –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å –∫–ª—é—á–æ–º –¥–æ—Å—Ç—É–ø–∞.

        Args:
            message (telegram.Message): –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç Telegram, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ.

        Raises:
            Exception: –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞—Ç—å –ø–æ–¥–ø–∏—Å–∫—É.
        """
        async with DatabaseContextManager() as session_methods:
            key_id = None

            try:
                in_payload = message.successful_payment.invoice_payload.split(':')
                duration_date = in_payload[1]
                user_id = message.from_user.id
                username = message.from_user.username

                # –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ –∏ —Å–æ–∑–¥–∞–Ω–∏–µ Shadowsocks –∫–ª—é—á–∞
                vless_manager, server_ip, key, key_id = await get_active_server_and_key(
                    user_id, username, session_methods
                )

                if not server_ip or not key or not key_id:
                    await logger.log_error(
                        message=f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{username}, ID {user_id} –ø–æ–ø—ã—Ç–∞–ª—Å—è –æ—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É, –Ω–æ –Ω–∏ –æ–¥–∏–Ω —Å–µ—Ä–≤–µ—Ä –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª",
                        error="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–µ—Å—Å–∏—é –Ω–∏ –ø–æ –æ–¥–Ω–æ–º—É –∏–∑ —Å–µ—Ä–≤–µ—Ä–æ–≤"
                    )
                    raise NoAvailableServersError("–Ω–µ—Ç –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–µ—Ä–æ–≤")

                # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏—ã
                service_id = int(in_payload[0])
                durations_days = int(in_payload[1])
                subscription_id = await SubscriptionService.create_subscription(
                    Subscriptions(
                        user_id=user_id,
                        service_id=service_id,
                        key=key,
                        key_id=key_id,
                        server_ip=server_ip,
                        name_app=NameApp.VLESS,
                        start_date=datetime.now(),
                        end_date=datetime.now() + timedelta(days=durations_days)
                    ),
                    session_methods=session_methods
                )
                if not subscription_id:
                    raise Exception("–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏")

                # –ö–æ–º–º–∏—Ç —Å–µ—Å—Å–∏–∏ –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
                await session_methods.session.commit()
                await SubscriptionsService.send_success_response(message, key, subscription_id)
                await logger.log_info(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{username}\n"
                                      f"ID: {user_id}\n"
                                      f"–û—Ñ–æ—Ä–º–∏–ª –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ {duration_date} –¥–Ω–µ–π")

                try:
                    await SubscriptionsService.process_referral_bonus(user_id, username, message.bot)
                except Exception:
                    pass

            except Exception as e:
                if isinstance(e, NoAvailableServersError):
                    await message.answer(text=LEXICON_RU['no_servers_available'])
                else:
                    await logger.log_error(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{username}, ID {user_id}\n–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏",
                                           e)
                    await message.answer(text=LEXICON_RU['purchase_cancelled'])

                await SubscriptionsService.refund_payment(message)

                await session_methods.session.rollback()

                if vless_manager and key_id:
                    await vless_manager.delete_key(key_id)

                await session_methods.session.commit()

    @staticmethod
    async def extend_sub_successful_payment(message: Message, state: FSMContext):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —É—Å–ø–µ—à–Ω–æ–µ –ø—Ä–æ–¥–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.

        Args:
            message (Message): –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç Telegram, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ.
            state (FSMContext): –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –ø–æ–¥–ø–∏—Å–∫–∏, –∫–æ—Ç–æ—Ä—É—é –±—É–¥–µ–º –ø—Ä–æ–¥–ª—è—Ç—å.
        """
        async with DatabaseContextManager() as session_methods:
            try:
                in_payload = message.successful_payment.invoice_payload.split(':')
                service_id = int(in_payload[0])
                durations_days = int(in_payload[1])
                user_data = await state.get_data()
                subscription_id = int(user_data.get('subscription_id')) if user_data.get('subscription_id') else None

                subs = await session_methods.subscription.get_subscription(message.from_user.id)
                if subs:
                    for sub in subs:
                        if sub.subscription_id == subscription_id:
                            if datetime.now() > sub.end_date:
                                new_end_date = datetime.now() + timedelta(days=int(durations_days))
                            else:
                                new_end_date = sub.end_date + timedelta(days=int(durations_days))
                            await session_methods.subscription.update_sub(
                                subscription_id=sub.subscription_id,
                                service_id=service_id,
                                end_date=new_end_date,
                                updated_at=datetime.now(),
                                status=SubscriptionStatusEnum.ACTIVE,
                                reminder_sent=0
                            )
                            await session_methods.subscription_history.create_history_entry(
                                user_id=message.from_user.id,
                                service_id=sub.service_id,
                                start_date=sub.start_date,
                                end_date=new_end_date,
                                status=StatusSubscriptionHistory.EXTENSION
                            )
                            await BaseKeyManager(server_ip=sub.server_ip).update_key_enable(
                                sub.key_id, True)
                            await logger.info(f"–£—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ {subscription_id}")
                            await session_methods.session.commit()
                            await message.answer(text=LEXICON_RU['subscription_renewed'])
                            await logger.log_info(
                                f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{message.from_user.username}\n"
                                f"ID: {message.from_user.id}\n"
                                f"–ü—Ä–æ–¥–ª–∏–ª –ø–æ–¥–ø–∏—Å–∫—É –Ω–∞ {durations_days} –¥–Ω–µ–π"
                            )
                            try:
                                await SubscriptionsService.process_referral_bonus(
                                    message.from_user.id,
                                    message.from_user.username,
                                    message.bot
                                )
                            except Exception:
                                pass
                            return
                raise NoActiveSubscriptionsError("–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫")

            except Exception as e:
                if isinstance(e, NoActiveSubscriptionsError):
                    await message.answer(
                        text="–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫\n\n–û—Ñ–æ—Ä–º–∏—Ç–µ –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É",
                        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
                            [
                                InlineKeyboardButton(
                                    text="üê≤ –û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É",
                                    callback_data="subscribe"
                                )
                            ]
                        ])
                    )
                else:
                    await message.answer(text=LEXICON_RU['purchase_cancelled'])
                await logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏–µ", e)
                await logger.log_error(
                    f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{message.from_user.username}\n"
                    f"ID: {message.from_user.id}\n"
                    f"Error during transaction processing", e
                )

                await SubscriptionsService.refund_payment(message)

                await session_methods.session.rollback()
                await session_methods.session.commit()
                return

    @staticmethod
    async def send_success_response(message: Message, vpn_key: str, subscription_id):
        await message.answer(
            text=LEXICON_RU[
                     'purchase_thank_you'] + f'\n–ö–ª—é—á –¥–æ—Å—Ç—É–ø–∞ VPN:\n<pre>{vpn_key}</pre>',
            parse_mode="HTML",
        )
        await message.answer(
            text=LEXICON_RU["choose_device"],
            reply_markup=await InlineKeyboards.get_menu_install_app(NameApp.VLESS, subscription_id)
        )

    @staticmethod
    async def refund_payment(message: Message):
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–æ–∑–≤—Ä–∞—Ç –ø–ª–∞—Ç–µ–∂–∞ —á–µ—Ä–µ–∑ Telegram.

        Args:
            message (telegram.Message): –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç Telegram, —Å–æ–¥–µ—Ä–∂–∞—â–µ–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–ª–∞—Ç–µ–∂–µ.
        """
        await message.bot.refund_star_payment(
            message.from_user.id,
            message.successful_payment.telegram_payment_charge_id
        )

    @staticmethod
    async def process_referral_bonus(user_id: int, username: str, bot):
        async with DatabaseContextManager() as session_methods:
            try:
                referrer_id = await session_methods.referrals.update_referral_status_if_invited(user_id)
                if referrer_id:
                    await extend_user_subscription(referrer_id, str(username), 15, session_methods)
                    await bot.send_message(referrer_id, LEXICON_RU['referrer_message'].format(username=username))
                    await logger.log_info(
                        f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å ID: {referrer_id} –ø–æ–ª—É—á–∞–µ—Ç 15 –¥–Ω—è –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—é: @{username}"
                    )
                    await session_methods.session.commit()
            except Exception as error:
                await session_methods.session.rollback()
                await logger.log_error(
                    f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –Ω–∞—á–∏—Å–ª–µ–Ω–∏–∏ –±–æ–Ω—É—Å–∞ –∑–∞ —Ä–µ—Ñ–µ—Ä–∞–ª –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å ID: {referrer_id}",
                    error
                )
        return True
